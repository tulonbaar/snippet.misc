#!/usr/bin/env bash
#
# IP Range Scanner - checks availability of IP addresses in the given range
# Author: Generated by GitHub Copilot
# Date: May 3, 2025

# Colors for result formatting
GREEN="\033[0;32m"
RED="\033[0;31m"
YELLOW="\033[0;33m"
BLUE="\033[0;34m"
RESET="\033[0m"

# Function to display header
function display_header() {
    clear
    echo -e "${BLUE}"
    echo "┌───────────────────────────────────────────┐"
    echo "│           IP RANGE SCANNER                │"
    echo "│   Checking IP address availability        │"
    echo "└───────────────────────────────────────────┘"
    echo -e "${RESET}"
}

# Function to display usage instructions
function usage() {
    echo -e "${YELLOW}Usage:${RESET}"
    echo -e "  $0 [options]"
    echo
    echo -e "${YELLOW}Options:${RESET}"
    echo -e "  -s, --start IP      Start IP address (e.g. 192.168.1.1)"
    echo -e "  -e, --end IP        End IP address (e.g. 192.168.1.254)"
    echo -e "  -r, --range CIDR    CIDR range (e.g. 192.168.1.0/24)"
    echo -e "  -c, --count N       Number of ping packets (default: 1)"
    echo -e "  -t, --timeout N     Timeout in seconds (default: 1)"
    echo -e "  -o, --output FILE   Save results to file"
    echo -e "  -h, --help          Show this help"
    echo
    echo -e "${YELLOW}Examples:${RESET}"
    echo -e "  $0 --start 192.168.1.1 --end 192.168.1.10"
    echo -e "  $0 --range 192.168.1.0/24"
    echo -e "  $0 --range 10.0.0.0/28 --count 2 --timeout 2"
}

# Variable initialization
START_IP=""
END_IP=""
CIDR_RANGE=""
PING_COUNT=1
PING_TIMEOUT=1
OUTPUT_FILE=""

# Argument parsing
while [[ $# -gt 0 ]]; do
    case $1 in
        -s|--start)
            START_IP="$2"
            shift 2
            ;;
        -e|--end)
            END_IP="$2"
            shift 2
            ;;
        -r|--range)
            CIDR_RANGE="$2"
            shift 2
            ;;
        -c|--count)
            PING_COUNT="$2"
            shift 2
            ;;
        -t|--timeout)
            PING_TIMEOUT="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        -h|--help)
            display_header
            usage
            exit 0
            ;;
        *)
            echo -e "${RED}Error: Unknown parameter $1${RESET}"
            usage
            exit 1
            ;;
    esac
done

# Convert IP address to decimal
function ip_to_decimal() {
    local ip="$1"
    local a b c d
    IFS=. read -r a b c d <<< "$ip"
    echo $(( (a << 24) + (b << 16) + (c << 8) + d ))
}

# Convert decimal to IP address
function decimal_to_ip() {
    local decimal="$1"
    local a b c d
    a=$(( (decimal >> 24) & 255 ))
    b=$(( (decimal >> 16) & 255 ))
    c=$(( (decimal >> 8) & 255 ))
    d=$(( decimal & 255 ))
    echo "$a.$b.$c.$d"
}

# Function to parse CIDR range
function parse_cidr() {
    local cidr="$1"
    local ip prefix
    
    # Extract IP address and prefix
    IFS=/ read -r ip prefix <<< "$cidr"
    
    # Convert IP address to decimal
    local ip_decimal=$(ip_to_decimal "$ip")
    
    # Calculate network mask
    local mask=$((0xFFFFFFFF << (32 - prefix)))
    
    # Calculate network and broadcast addresses
    local network=$((ip_decimal & mask))
    local broadcast=$(( network | (0xFFFFFFFF >> prefix) ))
    
    # First usable IP address (network address + 1)
    local first_ip=$((network + 1))
    
    # Last usable IP address (broadcast - 1)
    local last_ip=$((broadcast - 1))
    
    # Return first and last IP address
    echo "$(decimal_to_ip $first_ip) $(decimal_to_ip $last_ip)"
}

# Check if required parameters are provided
if [[ -z "$START_IP" && -z "$END_IP" && -z "$CIDR_RANGE" ]]; then
    echo -e "${RED}Error: You must specify an IP address range${RESET}"
    usage
    exit 1
fi

# If CIDR range is provided, calculate start and end addresses
if [[ -n "$CIDR_RANGE" ]]; then
    read -r START_IP END_IP <<< $(parse_cidr "$CIDR_RANGE")
    echo -e "${YELLOW}CIDR range $CIDR_RANGE converted to range from $START_IP to $END_IP${RESET}"
fi

# Check if both start and end addresses are provided
if [[ -z "$START_IP" || -z "$END_IP" ]]; then
    echo -e "${RED}Error: You must specify both start and end addresses${RESET}"
    usage
    exit 1
fi

# Convert IP addresses to decimals
START_DECIMAL=$(ip_to_decimal "$START_IP")
END_DECIMAL=$(ip_to_decimal "$END_IP")

# Check range validity
if [[ $START_DECIMAL -gt $END_DECIMAL ]]; then
    echo -e "${RED}Error: Start address ($START_IP) is greater than end address ($END_IP)${RESET}"
    exit 1
fi

# Prepare output file if specified
if [[ -n "$OUTPUT_FILE" ]]; then
    echo "Status,IP Address,Hostname,Response Time" > "$OUTPUT_FILE"
    echo -e "${YELLOW}Results will be saved to file: $OUTPUT_FILE${RESET}"
fi

display_header

# Calculate number of addresses to scan
TOTAL_IPS=$((END_DECIMAL - START_DECIMAL + 1))
echo -e "${YELLOW}Scanning $TOTAL_IPS IP addresses from $START_IP to $END_IP${RESET}"
echo -e "${YELLOW}Parameters: $PING_COUNT packet(s), timeout $PING_TIMEOUT s${RESET}"
echo

# Table header formatting
printf "%-5s %-15s %-20s %-15s\n" "No." "IP Address" "Hostname" "Status"
echo "------------------------------------------------------"

# Address counter
COUNT=1

# Process each IP address in range
for ((i=START_DECIMAL; i<=END_DECIMAL; i++)); do
    CURRENT_IP=$(decimal_to_ip $i)
    
    # Create progress bar
    PROGRESS=$((COUNT * 100 / TOTAL_IPS))
    printf "\r${YELLOW}Progress: [%-50s] %d%%" $(printf "%0.s#" $(seq 1 $((PROGRESS / 2)))) $PROGRESS
    
    # Execute ping with specified parameters and save result
    if ping -c $PING_COUNT -W $PING_TIMEOUT $CURRENT_IP >/dev/null 2>&1; then
        DOSTEPNOSC="Up"
        STATUS_COLOR=$GREEN
        RESPONSE_TIME=$(ping -c 1 -W $PING_TIMEOUT $CURRENT_IP | grep "time=" | cut -d "=" -f 4 | awk '{print $1}')
        
        # Try to get hostname
        HOST=$(host $CURRENT_IP 2>/dev/null | grep "domain name pointer" | awk '{print $5}' | sed 's/\.$//')
        if [[ -z "$HOST" ]]; then
            HOST="-"
        fi
        
        if [[ -n "$OUTPUT_FILE" ]]; then
            echo "UP,$CURRENT_IP,$HOST,$RESPONSE_TIME" >> "$OUTPUT_FILE"
        fi
    else
        DOSTEPNOSC="Down"
        STATUS_COLOR=$RED
        RESPONSE_TIME="-"
        HOST="-"
        
        if [[ -n "$OUTPUT_FILE" ]]; then
            echo "DOWN,$CURRENT_IP,$HOST,-" >> "$OUTPUT_FILE"
        fi
    fi
    
    # Clear progress line and display result for current address with correct colors
    printf "\r%-5d %-15s %-20s ${STATUS_COLOR}%-15s${RESET}\n" $COUNT "$CURRENT_IP" "$HOST" "$DOSTEPNOSC"
    
    COUNT=$((COUNT+1))
done

echo
echo -e "${GREEN}Scan completed.${RESET}"

if [[ -n "$OUTPUT_FILE" ]]; then
    echo -e "${GREEN}Results saved to file: $OUTPUT_FILE${RESET}"
fi

exit 0